#' RphenoGraph clustering
#' 
#' R implementation of the PhenoGraph algorithm
#' 
#' A simple R implementation of the [PhenoGraph](http://www.cell.com/cell/abstract/S0092-8674(15)00637-6) algorithm, 
#' which is a clustering method designed for high-dimensional single-cell data analysis. It works by creating a graph ("network") representing 
#' phenotypic similarities between cells by calclating the Jaccard coefficient between nearest-neighbor sets, and then identifying communities 
#' using the well known [Louvain method](https://sites.google.com/site/findcommunities/) in this graph. 
#' 
#' @param data matrix; input data matrix
#' @param k integer; number of nearest neighbours (default:30)
#' @param directed logical; whether to use a symmetric (default) or asymmetric ("directed") graph (default:FALSE)
#' @param prune logical; determines whether symmetric matrix is generated by iGraph (FALSE) or element-wise multiplication (TRUE) with the transpose (defaults:FALSE)
#' @param clust_fun function; community detection algorithm. Defaults to cluster_louvian. Other options: cluster_walktrap, cluster_spinglass, cluster_leading_eigen, cluster_edge_betweenness, cluster_fast_greedy, cluster_label_prop
#' @param verbose logical; verbosity (default=FALSE)
#' @param knn_fun function or character; the function used to search the nearest neighbors. NULL points to RANN::nn2 as original code. "hnsw" points to RcppHNSW::hnsw_knn as proposed by E. Becht. Any function that returns a matrix of index to nearest neighbors could be used. NB: the first column contains the point itself and is removed before building the graph.
#'
#' @return a list contains an igraph graph object for \code{graph_from_data_frame} and a communities object, the operations of this class contains:
#' \item{print}{returns the communities object itself, invisibly.}
#' \item{length}{returns an integer scalar.}
#' \item{sizes}{returns a numeric vector.}
#' \item{membership}{returns a numeric vector, one number for each vertex in the graph that was the input of the community detection.}
#' \item{modularity}{returns a numeric scalar.}
#' \item{algorithm}{returns a character scalar.}
#' \item{crossing}{returns a logical vector.}
#' \item{is_hierarchical}{returns a logical scalar.}
#' \item{merges}{returns a two-column numeric matrix.}
#' \item{cut_at}{returns a numeric vector, the membership vector of the vertices.}
#' \item{as.dendrogram}{returns a dendrogram object.}
#' \item{show_trace}{returns a character vector.}
#' \item{code_len}{returns a numeric scalar for communities found with the InfoMAP method and NULL for other methods.}
#' \item{plot}{for communities objects returns NULL, invisibly.}
#'  
#' @references Jacob H. Levine and et.al. Data-Driven Phenotypic Dissection of AML Reveals Progenitor-like Cells that Correlate with Prognosis. Cell, 2015.                
#' @examples
#' library(igraph)
#' iris_unique <- unique(iris) # Remove duplicates
#' data <- as.matrix(iris_unique[,1:4])
#' Rphenograph_out <- Rphenograph(data, k = 45)
#' modularity(Rphenograph_out[[2]])
#' membership(Rphenograph_out[[2]])
#' iris_unique$phenograph_cluster <- factor(membership(Rphenograph_out[[2]]))
#' if(require(ggplot2)) {
#'     ggplot(iris_unique, aes(x=Sepal.Length, y=Sepal.Width, col=Species, shape=phenograph_cluster)) +
#'         geom_point(size = 3) + theme_bw()
#' } else {
#'     with(iris_unique, plot(x=Sepal.Length, y=Sepal.Width, 
#'     col=Species, pch=(15:17)[phenograph_cluster], 
#'     cex=c(2.5, 2, 1.5)[phenograph_cluster]))
#' }
#' 
#' @importFrom igraph graph.data.frame cluster_louvain modularity membership as_adjacency_matrix graph_from_adjacency_matrix
#' @useDynLib Rphenograph
#' 
#' @export
Rphenograph <- function(data, k=30, 
                        directed=FALSE, prune=FALSE,
                        clust_fun=NULL, 
                        verbose=FALSE, 
                        knn_fun=NULL) {
    if(prune){
      print("Setting directed to FALSE because prune is TRUE")
      directed <- FALSE
    }
  
    if(is.data.frame(data))
        data <- as.matrix(data)
    
    if(!is.matrix(data))
        stop("Wrong input data, should be a data frame or matrix!")
    
    if(k<1){
        stop("k must be a positive integer!")
    }else if (k > nrow(data)-2){
        stop("k must be smaller than the total number of points!")
    }

    if(verbose){
        message("\nRun Rphenograph starts:\n", 
                "  -Input data of ", nrow(data)," rows and ", ncol(data), " columns","\n",
                "  -k is set to ", k)
        cat("  Finding nearest neighbors...")
    }
    if(is.null(knn_fun)) knn_fun <- find_neighbors
    if(is.character(knn_fun) && knn_fun == "hnsw")
      if (requireNamespace("RcppHNSW",  quietly = TRUE)) {
        knn_fun <- function(data, k) RcppHNSW::hnsw_knn(data, k=k+1)$idx
      } else
        stop("RcppHNSW must be installed for using hnsw nearest neighbors search.")
    if(!is.function(knn_fun))
        stop("knn_fun must be a function or a recognized keyword.")
    ## t1 <- system.time(neighborMatrix <- find_neighbors(data, k=k+1)[,-1])
    t1 <- system.time(neighborMatrix <- knn_fun(data, k)[,-1])

    if(verbose){
        cat("DONE ~",t1[3],"s\n", " Compute jaccard coefficient between nearest-neighbor sets...")
    }
    t2 <- system.time(links <- jaccard_coeff_3(neighborMatrix))

    if(verbose){
        cat("DONE ~",t2[3],"s\n", " Build undirected graph from the weighted links...")
    }
    links <- links[links[,1]>0, ]
    
    ## Fix if data point goes missing (due to all of its associated jaccard
    ## coefficients being 0 and if it ever appears as another points' nearest
    ## neighbor, the corresponding jaccard coefficient also being 0.
    u <- unique(c(links[,1],links[,2]))
    u <- setdiff(1:nrow(data),u) ## Check if data point has no link
    links <- rbind(links,matrix(ncol=3,byrow=FALSE,data=c(u,u,rep(1,length(u)))))
    
    relations <- as.data.frame(links)
    colnames(relations) <- c("from","to","weight")
    t3 <- system.time({
      if(prune){
        if(verbose)
            cat("\n", " Removing non-symmetric links...")
        g <- graph.data.frame(relations, directed=TRUE)
        mat <- as_adjacency_matrix(g, sparse = TRUE)
        mat <- mat * Matrix::t(mat)
        g <- graph_from_adjacency_matrix(mat, mode = "undirected")
        # alternative; whatever coding, pruning seems to increase the number of clusters
        # mat <- as_adjacency_matrix(g, sparse = TRUE)
        # g <- graph_from_adjacency_matrix(mat, mode = "min")
      } else {
        g <- graph.data.frame(relations, directed=directed)
      }
    })

    # Other community detection algorithms: 
    #    cluster_walktrap, cluster_spinglass, 
    #    cluster_leading_eigen, cluster_edge_betweenness, 
    #    cluster_fast_greedy, cluster_label_prop  
    if(is.null(clust_fun)) clust_fun <- cluster_louvain
    
    if(verbose) {
        cat("DONE ~",t3[3],"s\n")
        cat("  Run ", "clustering on the graph ...")  # TODO: add function name
    }
    t4 <- system.time(community <- clust_fun(g))
    if(verbose){
        cat("DONE ~",t4[3],"s\n")
        
        message("Run Rphenograph DONE, totally takes ", 
                format(sum(c(t1[3],t2[3],t3[3],t4[3])), digits = 5), " s.")
        cat("  Return a community class\n")
        cat("  -Modularity value:", modularity(community), "\n")
        cat("  -Number of clusters:", length(unique(membership(community))), "\n")
    }
    
    return(list(g, community))
}

#' K Nearest Neighbour Search
#'
#' Uses a kd-tree to find the p number of near neighbours for each point in an input/output dataset.
#' 
#' Use the nn2 function from the RANN package, utilizes the Approximate Near Neighbor (ANN) C++ library, 
#' which can give the exact near neighbours or (as the name suggests) approximate near neighbours 
#' to within a specified error bound. For more information on the ANN library please 
#' visit http://www.cs.umd.edu/~mount/ANN/.
#' 
#' @describeIn Rphenograph Uses a kd-tree to find the p number of near neighbours for each point in an input/output dataset.
#' 
#' @return a n-by-k matrix of neighbor indices
#' 
#' @examples
#' iris_unique <- unique(iris) # Remove duplicates
#' data <- as.matrix(iris_unique[,1:4])
#' neighbors <- find_neighbors(data, k=10)
#' 
#' @importFrom RANN nn2
#' @export
find_neighbors <- function(data, k){
    nearest <- nn2(data, data, k, searchtype = "standard")
    return(nearest[[1]])
}
